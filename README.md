Tools for processing memory traces, as generated by this customized development branch of zsim:
<https://github.com/andrewbartolo/zsim/tree/dev>.

## Prerequisites
You must have a distro and/or compiler that supports C++17 (e.g., gcc 7.0 or greater). After this, run `make` to build all tools.

## Tools
### SNStats
Single-node statistics. Given an input trace, reports statistics such as how many writes the most-written page and most-written cache line received.

- `-m`: input memtrace directory (generated by zsim)
- `-l`: line size in bytes
- `-p`: page size in bytes

### SNQueues
Single-node queues. Simulates a memory wear-leveling algorithm operating within a single node. Takes in an input trace, along with wear-leveling algorithm parameters, and outputs statistics such as the amount of lifetime achieved by the simulated system.

- `-n`: n. queues (buckets)
- `-c`: bit cell write endurance
- `-b`: input bittrack directory (more info. coming soon)
- `-m`: input memtrace directory (generated by zsim)
- `-w`: write factor mode (`average` or `per-page`)
- `-t`: time in seconds represented by the input trace
- `-i`: n. iterations to run the algorithm for
- `-e`: n. hierarchy promotions to trace
- `-g`: main memory size, bytes requested

### MNStats
Multi-node statistics. Takes in an input trace and, and assumes that each core lives within its own NUMA domain as a separate node. Outputs statistics such as number of on-/off-node reads/writes, average reads/writes per node, and ratio of on- and off-node reads/writes.

- `-a`: allocation mode (`first-touch` or `interleave`)
- `-m`: input memtrace directory (generated by zsim)
- `-n`: n. nodes
- `-l`: cache line size in bytes
- `-p`: page size in bytes

### MNQueues
Multi-node queues. Simulates a memory wear-leveling algorithm operating amongst multiple nodes. Takes in an input trace, along with wear-leveling algorithm parameters, and outputs statistics such as the amount of lifetime achieved by the simulated system.

- `-n`: n. queues (buckets)
- `-c`: bit cell write endurance
- `-l`: cache line size in bytes
- `-p`: page size in bytes
- `-i`: n. iterations to run the algorithm for
- `-e`: n. hierarchy promotions to trace
- `-g`: per-node main memory size in bytes
- `-t`: scheduler quanta (iteration time period) in seconds
- `-r`: whether/not to actually rebalance memory
- `-j`: input "jobs string", a single line of the form (shown on separate lines for clarity):

```
WORKLOAD0_WRITE_BANDWIDTH_BYTES_PER_S:
WORKLOAD0_RSS:
WORKLOAD0_WRITE_FACTOR,
WORKLOAD1_WRITE_BANDWIDTH_BYTES_PER_S:
WORKLOAD1_RSS:
WORKLOAD1_WRITE_FACTOR,
...
```

### EventTrace
Given an input trace and a simulated event duration, `eventtrace` loops over the trace and measures how large the queue depth of events grows (only one event can be serviced at a time).

- `-f`: input event trace filepath (generated by SNQueues or MNQueues)
- `-t`: type of input trace, `int` or `float`, depending on SNQueues or MNQueues
- `-d`: event duration

## Internals
### MemTraceReader
Helper class used by all the tools to loop through a trace output. If you're writing a custom tool, you'll want to include and use this.
